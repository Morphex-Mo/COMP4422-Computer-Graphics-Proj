# 资源加载器使用文档

## 概述

本项目提供了一套完整的资源加载和场景管理系统，支持异步加载各种资源（图片、音频、视频、Three.js模型、Shader等），并在资源加载完成后进入"场景"或"关卡"。

## 核心模块

### 1. ResourceLoader（资源加载器）

负责加载各种类型的资源。

#### 支持的资源类型

- `IMAGE` - 图片
- `AUDIO` - 音频
- `VIDEO` - 视频
- `SCRIPT` - JavaScript脚本
- `TEXTURE` - Three.js纹理
- `CUBE_TEXTURE` - 立方体纹理（天空盒）
- `MODEL_GLTF` - GLTF/GLB 3D模型
- `MODEL_FBX` - FBX 3D模型
- `MODEL_OBJ` - OBJ 3D模型
- `SHADER` - Shader文件（GLSL）
- `JSON` - JSON数据文件
- `FONT` - Three.js字体文件

#### 基础使用

```typescript
import { ResourceLoader, ResourceType } from './core';

const loader = new ResourceLoader();

// 加载单个资源
const resources = await loader.load({
    resources: [
        { key: 'myTexture', url: '/textures/ground.jpg', type: ResourceType.TEXTURE },
        { key: 'playerModel', url: '/models/player.gltf', type: ResourceType.MODEL_GLTF }
    ],
    onProgress: (key, loaded, total) => {
        console.log(`加载 ${key}: ${loaded}/${total}`);
    },
    onError: (key, error) => {
        console.error(`加载失败 ${key}: ${error}`);
    },
    onComplete: (resourceMap) => {
        console.log('所有资源加载完成！');
    }
});

// 获取已加载的资源
const texture = loader.get('myTexture');
const model = loader.get('playerModel');
```

### 2. SceneManager（场景管理器）

管理场景的注册、加载和切换。

```typescript
import { SceneManager } from './core';

const sceneManager = new SceneManager();

// 注册场景
sceneManager.registerScene({
    id: 'level1',
    name: '第一关',
    resources: [
        { key: 'bg', url: '/textures/bg.jpg', type: ResourceType.TEXTURE }
    ],
    onEnter: (resourceMap) => {
        // 场景入口逻辑
        const bgTexture = resourceMap.get('bg');
        // 初始化场景...
    },
    onExit: () => {
        // 场景退出时的清理逻辑
    }
});

// 加载并进入场景
await sceneManager.loadAndEnterScene('level1');
```

### 3. SceneLoader（场景加载器包装）

提供更简洁的API来定义和加载场景。

## 使用方法

### 方法一：使用 `defineScene`（推荐）

最简洁的方式，适合定义完整的场景/关卡。

```typescript
import { defineScene } from './core';

// 定义场景
const level1 = defineScene({
    id: 'level1',
    name: '第一关',
    resources: {
        // 纹理资源
        textures: {
            'ground': '/textures/ground.jpg',
            'wall': '/textures/wall.jpg',
            'sky': '/textures/sky.jpg'
        },
        // GLTF模型
        gltfModels: {
            'player': '/models/player.gltf',
            'enemy': '/models/enemy.gltf',
            'weapon': '/models/weapon.glb'
        },
        // Shader文件
        shaders: {
            'customVertex': '/shaders/custom.vert',
            'customFragment': '/shaders/custom.frag'
        },
        // JSON配置
        jsons: {
            'levelConfig': '/data/level1.json'
        }
    },
    // 加载进度回调
    onLoadProgress: (loaded, total, percentage) => {
        console.log(`加载进度: ${percentage}%`);
        // 更新进度条UI
    },
    // 场景主函数（所有资源加载完成后执行）
    main: async (resources) => {
        // 获取加载的资源
        const groundTexture = resources.get('ground');
        const playerModel = resources.get('player');
        const vertexShader = resources.get('customVertex');
        const config = resources.get('levelConfig');

        // 初始化Three.js场景
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        
        // 创建地面
        const groundGeo = new THREE.PlaneGeometry(50, 50);
        const groundMat = new THREE.MeshStandardMaterial({ map: groundTexture });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // 添加玩家模型
        const player = playerModel.scene;
        scene.add(player);

        // 开始游戏循环
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    },
    // 场景退出时的清理
    onExit: () => {
        console.log('退出关卡1');
        // 清理资源、停止动画等
    }
});

// 调用以进入场景
level1();
```

### 方法二：使用 `createLevelLoader`

适合快速包装关卡函数。

```typescript
import { createLevelLoader } from './core';

const startLevel2 = createLevelLoader(
    // 资源配置
    {
        textures: {
            'skybox': '/textures/skybox.jpg'
        },
        gltfModels: {
            'boss': '/models/boss.gltf'
        }
    },
    // 关卡函数
    (resources) => {
        const skyboxTexture = resources.get('skybox');
        const bossModel = resources.get('boss');
        
        // 初始化关卡...
        console.log('第二关开始！');
    },
    // 可选配置
    {
        id: 'level2',
        name: '第二关 - Boss战',
        onProgress: (percentage) => {
            console.log(`加载中: ${percentage}%`);
        }
    }
);

// 开始关卡
startLevel2();
```

### 方法三：带UI进度条

提供可视化的加载进度。

```typescript
import { defineScene, createLoadingUI } from './core';

function startGameWithUI() {
    // 创建加载UI
    const loadingUI = createLoadingUI('app');
    
    const gameScene = defineScene({
        id: 'main_game',
        name: '主游戏场景',
        resources: {
            textures: {
                'tex1': '/textures/1.jpg',
                'tex2': '/textures/2.jpg',
                'tex3': '/textures/3.jpg'
            },
            gltfModels: {
                'model1': '/models/1.gltf',
                'model2': '/models/2.gltf'
            }
        },
        onLoadProgress: (loaded, total, percentage) => {
            // 更新进度条
            loadingUI.update(percentage);
        },
        main: async (resources) => {
            // 移除加载UI
            loadingUI.remove();
            
            // 开始游戏
            console.log('游戏开始！');
            // ... 初始化游戏场景
        }
    });

    return gameScene();
}

// 启动游戏
startGameWithUI();
```

## 完整示例

### 示例1：完整的关卡系统

```typescript
// levels/level1.ts
import { defineScene } from '../core';
import * as THREE from 'three';

export const level1 = defineScene({
    id: 'level_1',
    name: '新手村',
    resources: {
        textures: {
            'grass': '/assets/textures/grass.jpg',
            'stone': '/assets/textures/stone.jpg'
        },
        gltfModels: {
            'house': '/assets/models/house.gltf',
            'tree': '/assets/models/tree.gltf',
            'npc': '/assets/models/npc.gltf'
        },
        jsons: {
            'enemies': '/assets/data/level1_enemies.json',
            'items': '/assets/data/level1_items.json'
        },
        shaders: {
            'waterVertex': '/assets/shaders/water.vert',
            'waterFragment': '/assets/shaders/water.frag'
        }
    },
    onLoadProgress: (loaded, total, percentage) => {
        document.getElementById('loading-text')!.textContent = 
            `加载中... ${percentage}%`;
    },
    main: async (resources) => {
        // 创建场景
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('app')!.appendChild(renderer.domElement);

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);

        // 创建地面
        const grassTexture = resources.get('grass');
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: grassTexture 
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // 添加房屋
        const houseModel = resources.get('house');
        const house = houseModel.scene.clone();
        house.position.set(10, 0, 10);
        scene.add(house);

        // 添加多棵树
        const treeModel = resources.get('tree');
        for (let i = 0; i < 20; i++) {
            const tree = treeModel.scene.clone();
            tree.position.set(
                (Math.random() - 0.5) * 80,
                0,
                (Math.random() - 0.5) * 80
            );
            tree.scale.setScalar(0.5 + Math.random() * 0.5);
            scene.add(tree);
        }

        // 添加NPC
        const npcModel = resources.get('npc');
        const npc = npcModel.scene.clone();
        npc.position.set(5, 0, 5);
        scene.add(npc);

        // 加载关卡配置
        const enemiesData = resources.get('enemies');
        const itemsData = resources.get('items');
        console.log('敌人配置:', enemiesData);
        console.log('道具配置:', itemsData);

        // 创建自定义水面材质
        const waterVertex = resources.get('waterVertex');
        const waterFragment = resources.get('waterFragment');
        const waterMaterial = new THREE.ShaderMaterial({
            vertexShader: waterVertex,
            fragmentShader: waterFragment,
            uniforms: {
                time: { value: 0 }
            }
        });
        const waterGeometry = new THREE.PlaneGeometry(30, 30);
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(-20, 0.1, -20);
        scene.add(water);

        // 设置相机
        camera.position.set(0, 10, 20);
        camera.lookAt(0, 0, 0);

        // 游戏循环
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            waterMaterial.uniforms.time.value = time;
            renderer.render(scene, camera);
        }
        animate();

        // 窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        console.log('关卡1加载完成！');
    },
    onExit: () => {
        console.log('退出关卡1，清理资源...');
    }
});
```

### 示例2：主菜单到关卡的流程

```typescript
// main.ts
import { defineScene, createLoadingUI } from './core';
import { level1 } from './levels/level1';

// 主菜单
const mainMenu = defineScene({
    id: 'main_menu',
    name: '主菜单',
    resources: {
        textures: {
            'menuBg': '/assets/ui/menu_bg.jpg',
            'logo': '/assets/ui/logo.png'
        }
    },
    main: async (resources) => {
        const appElement = document.getElementById('app')!;
        appElement.innerHTML = `
            <div style="background: url('${resources.get('menuBg').image.src}'); 
                        width: 100%; height: 100vh; 
                        display: flex; flex-direction: column; 
                        align-items: center; justify-content: center;">
                <img src="${resources.get('logo').image.src}" />
                <button id="start-btn" style="font-size: 24px; padding: 15px 30px;">
                    开始游戏
                </button>
            </div>
        `;

        document.getElementById('start-btn')!.addEventListener('click', () => {
            // 创建加载UI
            const loadingUI = createLoadingUI('app');
            
            // 重新定义level1以包含加载UI更新
            const level1WithUI = defineScene({
                ...level1,
                id: 'level1_with_ui',
                onLoadProgress: (loaded, total, percentage) => {
                    loadingUI.update(percentage);
                },
                main: async (resources) => {
                    loadingUI.remove();
                    await level1.onEnter(resources);
                }
            });

            level1WithUI();
        });
    }
});

// 启动应用
mainMenu();
```

## API参考

### defineScene(definition)

定义一个场景。

**参数：**
- `definition.id` (string) - 场景唯一标识
- `definition.name` (string) - 场景名称
- `definition.resources` (object) - 资源配置对象
  - `images` - 图片资源 { key: url }
  - `audios` - 音频资源 { key: url }
  - `videos` - 视频资源 { key: url }
  - `textures` - 纹理资源 { key: url }
  - `cubeTextures` - 立方体纹理 { key: [urls] }
  - `gltfModels` - GLTF模型 { key: url }
  - `fbxModels` - FBX模型 { key: url }
  - `objModels` - OBJ模型 { key: url }
  - `shaders` - Shader文件 { key: url }
  - `jsons` - JSON文件 { key: url }
  - `fonts` - 字体文件 { key: url }
- `definition.main` (function) - 场景入口函数
- `definition.onLoadProgress` (function, 可选) - 加载进度回调
- `definition.onExit` (function, 可选) - 场景退出回调

**返回值：**
- 返回一个函数，调用后开始加载并进入场景

### createLevelLoader(resources, levelFunction, options)

创建关卡加载器。

**参数：**
- `resources` (object) - 资源配置
- `levelFunction` (function) - 关卡主函数
- `options` (object, 可选) - 配置选项
  - `id` - 场景ID
  - `name` - 场景名称
  - `onProgress` - 进度回调
  - `onExit` - 退出回调

### createLoadingUI(containerId)

创建加载进度UI。

**参数：**
- `containerId` (string) - 容器元素ID，默认为 'app'

**返回值：**
- 返回对象包含：
  - `update(percentage)` - 更新进度
  - `remove()` - 移除UI

## 注意事项

1. **资源路径**：确保资源路径正确，相对于项目根目录
2. **Three.js加载器**：某些加载器（如FBXLoader）需要额外安装
3. **错误处理**：建议在生产环境中添加完善的错误处理
4. **内存管理**：场景切换时记得清理不再使用的资源
5. **跨域问题**：加载外部资源时注意CORS配置

## 最佳实践

1. **资源组织**：将资源按类型分文件夹存放
2. **按需加载**：只加载当前关卡需要的资源
3. **资源复用**：全局资源可以预先加载并缓存
4. **进度反馈**：为用户提供清晰的加载进度提示
5. **降级方案**：资源加载失败时提供默认资源或降级处理

